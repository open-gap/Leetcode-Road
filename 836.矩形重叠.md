# 矩形重叠 #  
`难度：简单` 

矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。  

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。  

给出两个矩形，判断它们是否重叠并返回结果。  

**示例 1**:  
>**输入**: rec1 = [0,0,2,2], rec2 = [1,1,3,3]  
>**输出**: true  

**示例 2**:  
>**输入**: rec1 = [0,0,1,1], rec2 = [1,0,2,1]  
>**输出**: false  

**说明**：  
- 两个矩形 `rec1` 和 `rec2` 都以含有四个整数的列表的形式给出。
- 矩形中的所有坐标都处于 `-10^9` 和 `10^9` 之间。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/rectangle-overlap/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：使用排除法，排除了矩形不相交情况  

```C++  
class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        if(rec1[3] <= rec2[1] || rec1[1] >= rec2[3]) return false;
        else if(rec1[2] <= rec2[0] || rec1[0] >= rec2[2]) return false;
        else return true;
    }
};
```  

**执行结果：**  
执行用时 : **4 ms** , 在所有 cpp 提交中击败了 **62.18%** 的用户  
内存消耗 : **9.3 MB** , 在所有 cpp 提交中击败了 **7.14%** 的用户  

---  
>解法二：投影法，假设存在相交矩形，则其边在垂直和水平轴上投影符合预期 (官方题解二)  

```C++  
class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        return (min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) && //垂直投影
                min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])); //水平投影
    }
};
```  

**执行结果：**  
执行用时 : **0 ms** , 在所有 cpp 提交中击败了 **100.00%** 的用户  
内存消耗 : **9.2 MB** , 在所有 cpp 提交中击败了 **7.14%** 的用户  

---  