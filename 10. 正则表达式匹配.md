# 正则表达式匹配 #  
`难度：困难`  
给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。  
```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```  
所谓匹配，是要涵盖 `整个` 字符串 `s` 的，而不是部分字符串。  

**说明：**  
>- `s`可能为空，且只包含从 `a-z` 的小写字母。  
>- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。  

**示例1：**  
>**输入：**   
s = "aa"  
p = "a"   
>**输出：** false  
>**解释：** "a" 无法匹配 "aa" 整个字符串。  

**示例2：**  
>**输入：**  
s = "aa"  
p = "a*"  
>**输出：** true  
>**解释：** 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。  

**示例3：**  
>**输入：**  
s = "ab"  
p = ".*"  
>**输出：** true    
>**解释：** ".\*" 表示可匹配零个或多个（'\*'）任意字符（'.'）。 

**示例4：**  
>**输入：**  
s = "aab"  
p = "c\*a\*b"  
>**输出：** true    
>**解释：** 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。  

**示例5：**  
>**输入：**  
s = "mississippi"  
p = "mis\*is\*p\*."  
>**输出：** false    

---
>解法一：最笨的方法——递归实现  

主要是对于*分成匹配当前字符或跳过当前字符两种情况，通过递归返回分情况下的最终匹配结果
```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        if(p.empty()) return s.empty();
        else if(s.empty())
        {
            if(p.length() % 2 != 0) return false;
            else
            {
                int tmpIndex = 1;
                while(p[tmpIndex] == '*') tmpIndex += 2;
                return tmpIndex >= p.length();
            }
        }
        else
        {
            return isMatchSub(s, p, 0, 0);
        }
    }

    bool isMatchSub(string &s, string &p, int sIndex, int pIndex)
    {
        if(sIndex >= s.length())
        {
            if(pIndex >= p.length()) return true;
            else if(pIndex + 1 < p.length() && p[pIndex + 1] == '*') return isMatchSub(s, p, sIndex, pIndex + 2);
            else return false;
        }
        else if(pIndex + 1 < p.length() && p[pIndex + 1] == '*')
        {
            if(s[sIndex] == p[pIndex] || p[pIndex] == '.') return isMatchSub(s, p, sIndex + 1, pIndex) || isMatchSub(s, p, sIndex, pIndex + 2);
            else return isMatchSub(s, p, sIndex, pIndex + 2);
        }
        else if(s[sIndex] == p[pIndex] || p[pIndex] == '.') return isMatchSub(s, p, sIndex + 1, pIndex + 1);
        else return false;
    }
};
```  

**执行结果：**  
执行用时 : **36 ms** , 在所有 cpp 提交中击败了 **47.03%** 的用户  
内存消耗 : **8.2 MB** , 在所有 cpp 提交中击败了 **97.09%** 的用户  

---  
>解法二：动态规划  

