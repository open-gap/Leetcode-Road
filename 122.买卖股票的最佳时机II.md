# 买卖股票的最佳时机 II #  
`难度：简单` 

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。  

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  

**示例 1**:  

>**输入**: [7,1,5,3,6,4]  
>**输出**: 7  
>**解释**: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  
>&emsp;&emsp;随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。  

**示例 2**:  

>**输入**: [1,2,3,4,5]  
>**输出**: 4  
>**解释**: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  
>&emsp;&emsp;注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  
>&emsp;&emsp;因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。  

**示例 3**:  

>**输入**: [7,6,4,3,1]  
>**输出**: 0  
>**解释**: 在这种情况下, 没有交易完成, 所以最大利润为 0。  

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：顺序扫描数组，只要出现减少趋势则出手股票并入手下降价格后的股票，是一种贪心算法，在官方题解中又称为峰谷法  

```C++  
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0, minPrices = 0, length = prices.size();
        for(int i = 0; i < length - 1; ++i)
        {
            if(prices[i] > prices[i + 1])
            {
                result += prices[i] - prices[minPrices];
                minPrices = i + 1;
            }
        }
        if(minPrices < length - 1) result += prices.back() - prices[minPrices];
        return result;
    }
};
```  

**执行结果：**  
执行用时 : **8 ms** , 在所有 cpp 提交中击败了 **71.46%** 的用户  
内存消耗 : **9.7 MB** , 在所有 cpp 提交中击败了 **7.50%** 的用户  

---  
>解法二：简单的一次遍历法，只考虑叠加上升坡段(题解)  

```C++  
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1; i < prices.size(); ++i)
        {
            if(prices[i] > prices[i - 1]) result += prices[i] - prices[i - 1];
        }
        return result;
    }
};
```  

**执行结果：**  
执行用时 : **8 ms** , 在所有 cpp 提交中击败了 **71.46%** 的用户  
内存消耗 : **9.6 MB** , 在所有 cpp 提交中击败了 **9.01%** 的用户  

---  