# 有效的数独 #  
`难度：中等` 
 
判断一个 `9x9` 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![数独](./pic/250px_Sudoku.png "数独示意图")  
上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。  

**示例1：**  
>**输入:**   
>[  
>&emsp;`["5","3",".",".","7",".",".",".","."]`,  
>&emsp;`["6",".",".","1","9","5",".",".","."]`,  
>&emsp;`[".","9","8",".",".",".",".","6","."]`,  
>&emsp;`["8",".",".",".","6",".",".",".","3"]`,  
>&emsp;`["4",".",".","8",".","3",".",".","1"]`,  
>&emsp;`["7",".",".",".","2",".",".",".","6"]`,  
>&emsp;`[".","6",".",".",".",".","2","8","."]`,  
>&emsp;`[".",".",".","4","1","9",".",".","5"]`,  
>&emsp;`[".",".",".",".","8",".",".","7","9"]`  
>]  
>**输出:** true  

**示例2：**  
>**输入:**   
>[  
>&emsp;`["8","3",".",".","7",".",".",".","."]`,  
>&emsp;`["6",".",".","1","9","5",".",".","."]`,  
>&emsp;`[".","9","8",".",".",".",".","6","."]`,  
>&emsp;`["8",".",".",".","6",".",".",".","3"]`,  
>&emsp;`["4",".",".","8",".","3",".",".","1"]`,  
>&emsp;`["7",".",".",".","2",".",".",".","6"]`,  
>&emsp;`[".","6",".",".",".",".","2","8","."]`,  
>&emsp;`[".",".",".","4","1","9",".",".","5"]`,  
>&emsp;`[".",".",".",".","8",".",".","7","9"]`  
>]  
>**输出:** true  
>**解释:** 除了第一行的第一个数字从 `5` 改为 `8` 以外，空格内其他数字均与 `示例1` 相同。  
>&emsp;&emsp;但由于位于左上角的 `3x3` 宫内有两个 `8` 存在, 因此这个数独是无效的。  

**说明:**  
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/valid-sudoku/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：双重循环遍历整个数独，根据记录的遍历情况返回结果  

```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<vector<bool> > rows(9, vector<bool>(9, false)), cols(9, vector<bool>(9, false)), recs(9, vector<bool>(9, false));
        int temp = 0;
        for(int i = 0; i < 9; ++i)
        {
            for(int j = 0; j < 9; ++j)
            {
                if(board[i][j] == '.') continue;
                else
                {
                    temp = board[i][j] - '1';
                    // 判断行
                    if(rows[i][temp]) return false;
                    else rows[i][temp] = true;
                    // 判断列
                    if(cols[j][temp]) return false;
                    else cols[j][temp] = true;
                    // 判断方格
                    if(recs[(i / 3) * 3 + j / 3][temp]) return false;
                    else recs[(i / 3) * 3 + j / 3][temp] = true;
                }
            }
        }
        return true;
    }
};
```  

**执行结果：**  
执行用时 : **20 ms** , 在所有 cpp 提交中击败了 **63.23%** 的用户  
内存消耗 : **10.8 MB** , 在所有 cpp 提交中击败了 **79.13%** 的用户  

---  
>解法二：使用C数组代替C++的vector  

这个例子也说明了原生的C数组在已知大小的情况下相比vector的优势
```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int temp = 0, rows[9][9] = {0}, cols[9][9] = {0}, recs[9][9] = {0};
        for(int i = 0; i < 9; ++i)
        {
            for(int j = 0; j < 9; ++j)
            {
                if(board[i][j] == '.') continue;
                else
                {
                    temp = board[i][j] - '1';
                    if(rows[i][temp]++) return false;//判断行
                    if(cols[j][temp]++) return false;//判断列
                    if(recs[(i / 3) * 3 + j / 3][temp]++) return false;//判断方格
                }
            }
        }
        return true;
    }
};
```  

**执行结果：**  
执行用时 : **8 ms** , 在所有 cpp 提交中击败了 **99.54%** 的用户  
内存消耗 : **9.2 MB** , 在所有 cpp 提交中击败了 **97.23%** 的用户  

---  