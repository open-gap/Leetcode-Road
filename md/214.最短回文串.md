# 最短回文串 #  
`难度：困难` 

给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。    

**示例 1**:  
>**输入**: "aacecaaa"  
>**输出**: "aaacecaaa"  

**示例 2**:  
>**输入**: "abcd"  
>**输出**: "dcbabcd"  

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/shortest-palindrome/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法零：双重循环判断回文串，然后将剩余部分翻转，时间复杂度*O*(*n*^2)，超时  

```C++  
class Solution {
public:
    string shortestPalindrome(string s) {
        int n = s.length(), i = n - 1;
        if(n < 2) return s;
        for(; i > 0; --i)
        {
            if(s[i] == s[0])
            {
                bool flag = true;
                int left = 0, right = i;
                while(++left < --right)
                {
                    if(s[left] != s[right])
                    {
                        flag = false;
                        break;
                    }
                }
                if(flag) break;
            }
        }
        if(i == n - 1) return s;
        string temp = s.substr(i + 1);
        reverse(temp.begin(), temp.end());
        return temp + s;
    }
};
```  
119 / 120 个通过测试用例

---  
>解法零点五：使用马拉车算法判断最大回文串，然后将剩余部分翻转拼接到字符串首即为结果，超时  

```C++  
class Solution {
public:
    string shortestPalindrome(string s) {
        if(s.empty()) return s;
        string temp = "!";
        for(char ch : s) temp = temp + '#' + ch;
        temp += "#@";
        int m = temp.length(), imax = 2, rmax = 0, index = 0;
        vector<int> dp(m, 1);
        for(int i = 2; i <= m / 2; ++i)
        {
            if(i < rmax) dp[i] = min(rmax - i + 1, dp[2 * imax - i]);
            while(temp[i + dp[i]] == temp[i - dp[i]]) ++dp[i];
            if(i + dp[i] - 1 > rmax)
            {
                rmax = i + dp[i] - 1;
                imax = i;
            }
            if(dp[i] - i == 0) index = i;//找到最大的对称中心坐标
        }
        if(2 * index + 1 == m) return s;
        temp = s.substr(index - 1);
        reverse(temp.begin(), temp.end());
        return temp + s;
    }
};
```  
119 / 120 个通过测试用例

---  