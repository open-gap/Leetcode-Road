# 统计「优美子数组」 #  
`难度：中等` 

给你一个整数数组 `nums` 和一个整数 `k`。  

如果某个 **连续** 子数组中恰好有 `k` 个奇数数字，我们就认为这个子数组是「**优美子数组**」。  

请返回这个数组中「优美子数组」的数目。  

**示例 1**:  
>**输入**: nums = [1,1,2,1,1], k = 3  
>**输出**: 2  
>**解释**: 包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。  

**示例 2**:  
>**输入**: nums = [2,4,6], k = 1  
>**输出**: 0  
>**解释**: 数列中不包含任何奇数，所以不存在优美子数组。  

**示例 3**:  
>**输入**: nums = [2,2,2,1,2,2,1,2,2,2], k = 2  
>**输出**: 16  

**提示**：  
- `1 <= nums.length <= 50000`  
- `1 <= nums[i] <= 10^5`  
- `1 <= k <= nums.length`  

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/count-number-of-nice-subarrays/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：先统计奇数所在的下标，再通过滑动窗口的方式计算目标数组数量  

```C++  
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        int num = 0, size = nums.size(), length;
        vector<int> index;
        for(int i = 0; i < size; ++i)
        {
            if(nums[i] % 2 != 0) index.push_back(i);
        }
        length = index.size();
        if(length < k) return 0;
        else --k;
        for(int i = 0; i + k < length; ++i)
        {
            int left, right;
            if(i == 0) left = index[i] + 1;
            else left = index[i] - index[i - 1];
            if(i + k == length - 1) right = size - index[i + k];
            else right = index[i + k + 1] - index[i + k];
            num += left * right;
        }
        return num;
    }
};
```  

**执行结果：**  
执行用时 : **272 ms** , 在所有 cpp 提交中击败了 **56.54%** 的用户  
内存消耗 : **66.8 MB** , 在所有 cpp 提交中击败了 **100.00%** 的用户  

---  
>解法二：前缀和+差分 (官方题解二)

```C++  
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), odd = 0, ans = 0;
        vector<int> cnt(n + 1, 0);
        cnt[0] = 1;
        for(int i = 0; i < n; ++i)
        {
            odd += nums[i] & 1;//前i+1个元素中还有奇数的个数
            ans += odd >= k ? cnt[odd - k] : 0;
            ++cnt[odd];//统计有odd个奇数的子数组个数
        }
        return ans;
    }
};
```  

**执行结果：**  
执行用时 : **272 ms** , 在所有 cpp 提交中击败了 **56.54%** 的用户  
内存消耗 : **66 MB** , 在所有 cpp 提交中击败了 **100.00%** 的用户  

---  