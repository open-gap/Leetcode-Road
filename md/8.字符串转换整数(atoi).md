# 字符串转换整数 (atoi) #  
`难度：中等`  

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。  

**说明：**  
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。  

**示例1：**  
>**输入：** "42"  
>**输出：** 42  

**示例2：**  
>**输入：** "   -42"  
>**输出：** -42  
>**解释：** 第一个非空白字符为 '-', 它是一个负号。  
>&emsp;&emsp;我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

**示例3：**  
>**输入：** "4193 with words"  
>**输出：** 4193  
>**解释：** 转换截止于数字 '3' ，因为它的下一个字符不为数字。  

**示例4：**  
>**输入：** "words and 987"  
>**输出：** 0  
>**解释：** 第一个非空字符是 'w', 但它不是数字或正、负号。  
>&emsp;&emsp;因此无法执行有效的转换。  

**示例5：**  
>**输入：** "-91283472332"  
>**输出：** -2147483648  
>**解释：** 数字 "-91283472332" 超过 32 位有符号整数范围。   
>&emsp;&emsp;因此返回 INT_MIN (−2^31) 。  

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/string-to-integer-atoi/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：  

安装题目要求一步一步实现，主要注意溢出情况下的处理  
```C++
class Solution {
public:
    int myAtoi(string str) {
        int result = 0, nums = 0;
        bool signal = true, hasSingalOrNums = false;
        for(int i = 0; i < str.size(); i++)
        {
            if(result != 0)
            {
                if(str[i] < '0' || str[i] > '9') return signal ? result : 0 - result;
                else
                {
                    nums = (int)(str[i] - '0');
                    if(result > INT_MAX / 10) return signal ? INT_MAX : INT_MIN;
                    else if(result == INT_MAX / 10)
                    {
                        if(signal && nums > 7) return INT_MAX;
                        else if(!signal && nums >= 8) return INT_MIN;
                    }
                    result = result * 10 + nums;
                }
            }
            else
            {
                if(str[i] == ' ')
                {
                    if(hasSingalOrNums) return 0;
                    else continue;
                }
                else if(str[i] == '-' || str[i] == '+')
                {
                    if(hasSingalOrNums) return 0;
                    else
                    {
                        hasSingalOrNums = true;
                        if(str[i] == '-') signal = false;
                    }
                }
                else if(str[i] >= '0' && str[i] <= '9')
                {
                    hasSingalOrNums = true;
                    result = (int)(str[i] - '0');
                }
                else
                {
                    return 0;
                }
            }
        }
        return signal ? result : 0 - result;
    }
};
```  

**执行结果：**  
执行用时 : **0 ms** , 在所有 cpp 提交中击败了 **100.00%** 的用户  
内存消耗 : **8.3 MB** , 在所有 cpp 提交中击败了 **93.80%** 的用户  

---  
>解法一点五：简化程序的处理逻辑，缩减代码量 (题解)  

```C++  
class Solution {
public:
    int myAtoi(string str) {
        if(str.empty()) return 0;
        int sign = 1, base = 0, i = 0, n = str.size();
        while(i < n && str[i] == ' ') ++i;//删除前置空格
        if(i < n && (str[i] == '+' || str[i] == '-'))
        {
            sign = (str[i++] == '+') ? 1 : -1;//判断符号
        }
        while(i < n && str[i] >= '0' && str[i] <= '9')//逐渐转化数字
        {
            if(base > INT_MAX / 10 || (base == INT_MAX / 10 && str[i] - '0' > 7))
            {
                return (sign == 1) ? INT_MAX : INT_MIN;
            }
            base = 10 * base + (str[i++] - '0');
        }
        return base * sign;
    }
};
```  

**执行结果：**  
执行用时 : **4 ms** , 在所有 cpp 提交中击败了 **85.86%** 的用户  
内存消耗 : **6.2 MB** , 在所有 cpp 提交中击败了 **100.00%** 的用户  

---  
>解法二：自动机法 (官方题解一)  

本题可以建立如下自动机：  

![自动机](../pic/8_fig1.png)  

也可以通过以下表格表示：  

state | ' ' | +/- | number | other | 
------- | ------- | ------- | ------- | ------- | 
**start** | start | signed | in_number | end | 
**signed** | end | end | in_number | end | 
**in_number** | end | end | in_number | end | 
**end** | end | end | end | end | 

接下来只需要根据运行状态和转移的方向即可完成。   

```C++  
// 定义自动机类
class Automaton {
    string state = "start";//初始状态
    // 状态转移哈希表
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };
    // 决定状态转移方向
    int get_col(char c) {
        if(isspace(c)) return 0;
        if(c == '+' or c == '-') return 1;
        if(isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;//记录数字符号
    long long ans = 0;//记录最终结果用于返回
    // 状态转移和记录结果函数
    void get(char c) {
        state = table[state][get_col(c)];
        if(state == "in_number")
        {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if(state == "signed") sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for(char c : str) automaton.get(c);//遍历字符串输入自动机处理
        return automaton.sign * automaton.ans;
    }
};
```  

**执行结果：**  
执行用时 : **36 ms** , 在所有 cpp 提交中击败了 **12.26%** 的用户  
内存消耗 : **10.1 MB** , 在所有 cpp 提交中击败了 **5.09%** 的用户  

---  