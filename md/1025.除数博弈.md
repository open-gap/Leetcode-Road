# 除数博弈 #  
`难度：简单` 

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。  

最初，黑板上有一个数字 `N` 。在每个玩家的回合，玩家需要执行以下操作：  
- 选出任一 `x`，满足 `0 < x < N` 且 `N % x == 0` 。  
- 用 `N - x` 替换黑板上的数字 `N` 。  

如果玩家无法执行这些操作，就会输掉游戏。  

只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `false`。假设两个玩家都以最佳状态参与游戏。  

**示例 1**:  
>**输入**: 2  
>**输出**: true  
>**解释**: 爱丽丝选择 1，鲍勃无法进行操作。  

**示例 2**:  
>**输入**: 3  
>**输出**: false  
>**解释**: 爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。  

**提示**：  
1. `1 <= N <= 1000`  

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/divisor-game/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：模拟法，使用动态规划数组递推数字结果，其中只要找到一个约数使得当前数字减去约数为必输结果，则当前为必赢结果，否则为必输结果  

```C++  
class Solution {
public:
    bool divisorGame(int N) {
        vector<bool> dp(N + 1, false);
        for(int i = 2; i <= N; ++i)
        {
            for(int j = 1; j <= sqrt(i); ++j)
            {
                if(i % j == 0 && !dp[i - j])
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[N];
    }
};
```  

**执行结果：**  
执行用时 : **0 ms** , 在所有 cpp 提交中击败了 **100.00%** 的用户  
内存消耗 : **6.4 MB** , 在所有 cpp 提交中击败了 **100.00%** 的用户  

---  
>解法二：数学法，因为奇数减去一个约数必定变成偶数，因此只要先手拿到数字为偶数则必胜(通过减去约数的方式使得对手的数字为奇数，则最后必定会剩余1给对手从而使得对手无法操作而获胜)，反之先手拿到奇数则必输  

```C++  
class Solution {
public:
    bool divisorGame(int N) {
        return N % 2 == 0;
    }
};
```  

**执行结果：**  
执行用时 : **0 ms** , 在所有 cpp 提交中击败了 **100.00%** 的用户  
内存消耗 : **6.1 MB** , 在所有 cpp 提交中击败了 **100.00%** 的用户  

---  