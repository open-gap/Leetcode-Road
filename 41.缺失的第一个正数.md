# 缺失的第一个正数 #  
`难度：困难` 
 
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。   

**示例1：**  
>输入: [1,2,0]  
>输出: 3   

**示例2：**  
>输入: [3,4,-1,1]  
>输出: 2   

**示例3：**  
>输入: [7,8,9,11,12]  
>输出: 1   

**说明:**  

你的算法的时间复杂度应为 `O(n)`，并且只能使用常数级别的空间。  


来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/first-missing-positive/  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---  
>解法一：使用三次循环，分别查找最大值、设定标记、查找最小标记  

```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int max = 0;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(nums[i] > max) max = nums[i]; 
        }
        vector<bool> list(max, false);
        for(int j = 0; j < nums.size(); ++j)
        {
            if(nums[j] <= 0) continue;
            else list[nums[j] - 1] = true;
        }
        for(int k = 0; k < max; ++k)
        {
            if(!list[k]) return k + 1;
        }
        return max + 1;
    }
};
```  

**执行结果：**  
执行用时 : **192 ms** , 在所有 cpp 提交中击败了 **8.41%** 的用户  
内存消耗 : **303.2 MB** , 在所有 cpp 提交中击败了 **5.12%** 的用户  

---  
>解法二：来自LeetCode讨论区的有限空间数组法  

关键就是建立有限的空间大小，超过该空间的数字不考虑，主要应用数字的连续性性质  
```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int length = nums.size();
        vector<bool> list(length, false);
        for(int i = 0; i < length; ++i)
        {
            if(nums[i] <= 0 || nums[i] > length) continue;
            else list[nums[i] - 1] = true;
        }
        for(int j = 0; j < length; ++j)
        {
            if(!list[j]) return j + 1;
        }
        return length + 1;
    }
};
```  

**执行结果：**  
执行用时 : **4 ms** , 在所有 cpp 提交中击败了 **83.18%** 的用户  
内存消耗 : **8.5 MB** , 在所有 cpp 提交中击败了 **91.98%** 的用户  

---  