# 寻找两个有序数组的中位数 #  
`难度：困难`  
给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

**示例 1：**  
>nums1 = [1, 3]  
>nums2 = [2]  
>  
>则中位数是 2.0  

**示例 2：**  
>nums1 = [1, 2]  
>nums2 = [3, 4]  
>  
>则中位数是 (2 + 3)/2 = 2.5  
---  

>解法一：  

通过新建数组合并两个有序数组，通过合并后的数组找到中位数
```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int nums1Index = 0, nums2Index = 0, sumsIndex = 0, maxLength1 = nums1.size(), maxLength2 = nums2.size();
        vector<int> sums(maxLength1 + maxLength2, 0);//合并后的结果数组
        if(nums1.empty() || nums2.empty())//某个数组为空情况
        {
            sums = nums1.empty() ? nums2 : nums1;
        }
        else//两个数组均非空的情况
        {
            for(sumsIndex = 0; sumsIndex < maxLength1 + maxLength2; sumsIndex++)
            {
                if(nums1Index == maxLength1)//数组一已经遍历完毕
                {
                    sums[sumsIndex] = nums2[nums2Index];
                    nums2Index++;
                }
                else if(nums2Index == maxLength2)//数组二已遍历完毕
                {
                    sums[sumsIndex] = nums1[nums1Index];
                    nums1Index++;
                }
                else if(nums1[nums1Index] == nums2[nums2Index])//没有数组遍历完毕，但两个数组有相同数字
                {
                    sums[sumsIndex] = nums1[nums1Index];
                    sumsIndex++;
                    sums[sumsIndex] = nums2[nums2Index];
                    nums1Index++;
                    nums2Index++;
                }
                else if(nums1[nums1Index] < nums2[nums2Index])//第一个数组数字小于第二个数组数字
                {
                    sums[sumsIndex] = nums1[nums1Index];
                    nums1Index++;
                }
                else//第二个数组数字小于第一个数组数字
                {
                    sums[sumsIndex] = nums2[nums2Index];
                    nums2Index++;
                }
            }
        }
        // 根据结果数组求中位数
        if((maxLength1 + maxLength2) % 2 > 0)//结果数组为奇数个数字
        {
            return (double)sums[(maxLength1 + maxLength2) / 2];
        }
        else//结果数组为偶数个数字
        {
            return (double)(sums[(maxLength1 + maxLength2) / 2 - 1] + sums[(maxLength1 + maxLength2) / 2]) / 2.0;
        }
        
    }
};
```  

**执行结果：**  
执行用时 : **24 ms** , 在所有 cpp 提交中击败了 **75.21%** 的用户  
内存消耗 : **9.9 MB** , 在所有 cpp 提交中击败了 **82.06%** 的用户  

---